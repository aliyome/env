CLAUDE.md という名前にすると、実際に読み込まれてしまうので、敢えてファイル名に `_template` をつけています。
以下はよく使う CLAUDE.md の一部です。 bun + option-t を使うプロジェクトで有効です。

## Basic Rules

- TypeScript の実行環境として Bun を使用する
- t-wada が推奨する TDD で開発する
  1. 網羅したいテストシナリオのリスト（テストリスト）を書く
  2. テストリストの中から「ひとつだけ」選び出し、実際に、具体的で、実行可能なテストコードに翻訳し、テストが失敗することを確認する 3.プロダクトコードを変更し、いま書いたテスト（と、それまでに書いたすべてのテスト）を成功させる（その過程で気づいたことはテストリストに追加する）
  3. 必要に応じてリファクタリングを行い、実装の設計を改善する
     テストリストが空になるまでステップ 2 に戻って繰り返す
- 各ステップの最後に lint, test, commit を行う
- 明示的なユーザーの承認なしに lint ルールを無効にしない
- コミットメッセージは Conventional Commit 形式に従い、日本語で書く

## Coding Rules

- 関数型ドメインモデリングで設計する
  - **`class` は使わない。** `function` を使う
  - 代数的データ型を使う
- 例外を Throw しない
  - 失敗する可能性のある関数は `option-t` を使って `Result<T, E>` を返す
  - 外部ライブラリ等で throw される例外は `try catch` と `option-t` の `createErr` を使ってラップする
  - `isOk()`, `isErr()` を利用する。 `mapForResult()`, `andThenForResult()` をなるべく利用しない
- 早期リターンを使用して可読性を向上させる
- `Result<T, E>` 型のテストでは、エラーケースで `throw new Error("unreachable")` を使用する
- コメントとテストケースは日本語で書く

## Single Responsibility and API Minimization

- 責務ごとにファイルを分割し、各ファイルが単一の責務を持つようにする
- 公開 API は最小限に保ち、実装の詳細は隠蔽する
  - 最小限の関数や型のみ export する
- モジュールの境界と依存関係を最小限に抑える

## Backend Development

- Domain Driven Design
- ディレクトリ構造は packaging by feature
- 高階関数による DI

## Gemini の活用

人間の**意思決定**、Claude Code の**分析と実行**、Gemini MCP の**検証と助言**を組み合わせ、開発の質と速度を最大化する：

- **人間 (ユーザー)**：プロジェクトの目的・要件・最終ゴールを定義し、最終的な意思決定を行う**意思決定者**
  - 反面、具体的なコーディングや詳細な計画を立てる力、タスク管理能力ははありません。
- **Claude Code**：高度なタスク分解・高品質な実装・リファクタリング・ファイル操作・タスク管理を担う**実行者**
  - 指示に対して忠実に、順序立てて実行する能力はありますが、意志がなく、思い込みは勘違いも多く、思考力は少し劣ります。
- **Gemini MCP**：API・ライブラリ・エラー解析など**コードレベル**の技術調査・Web 検索 (Google 検索) による最新情報へのアクセスを行う**コード専門家**
  - ミクロな視点でのコード品質・実装方法・デバッグに優れますが、アーキテクチャ全体の設計判断は専門外です。

### 主要な活用場面

1. **実現不可能な依頼**: Claude Code では実現できない要求への対処 (例: `最新のニュース記事を取得して`)
2. **前提確認**: 要求の理解や実装方針の妥当性を確認 (例: `この実装方針で要件を満たせるか確認して`)
3. **技術調査**: 最新情報・エラー解決・ドキュメント検索 (例: `Rails 7.2の新機能を調べて`)
4. **設計立案**: 新機能の設計・アーキテクチャ構築 (例: `認証システムの設計案を作成して`)
5. **問題解決**: エラーや不具合の原因究明と対処 (例: `このTypeScriptエラーの解決方法を教えて`)
6. **コードレビュー**: 品質・保守性・パフォーマンスの評価 (例: `このコードの改善点は？`)
7. **計画立案**: タスク分解・実装方針の策定 (例: `ユーザー認証機能を実装するための計画を立てて`)
8. **技術選定**: ライブラリ・フレームワークの比較検討 (例: `状態管理にReduxとZustandどちらが適切か？`)
9. **リスク評価**: 実装前の潜在的問題の洗い出し (例: `この実装のセキュリティリスクは？`)
10. **設計検証**: 既存設計の妥当性確認・改善提案 (例: `現在のAPI設計の問題点と改善案は？`)
